generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------------
// ENUMS
// ------------------------------

enum UserRole {
  SUPER_ADMIN
  ADMIN
  USER
}

enum JoinStatus {
  PENDING
  APPROVED
  REJECTED
  NEED_UPDATE
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ResidentStatus {
  RESIDENCE
  NO_RESIDENCE
}

enum IsHouseholder {
  HOUSEHOLDER
  MEMBER
}

enum BoardType {
  NOTICE
  POLL
  COMPLAINT
}

enum NoticeCategory {
  MAINTENANCE // 정기점검
  EMERGENCY // 긴급사항
  COMMUNITY // 커뮤니티
  RESIDENT_VOTE // 주민투표
  RESIDENT_COUNCIL // 입주자대표회의
  COMPLAINT // 민원
  ETC // 기타
}

enum EventCategory {
  MAINTENANCE
  RESIDENT_VOTE
  COMPLAINT
  GENERAL
}

enum ComplaintStatus {
  PENDING
  IN_PROGRESS
  RESOLVED
  REJECTED
}

enum NotificationType {
  GENERAL
  SIGNUP_REQ
  COMPLAINT_REQ
  COMPLAINT_IN_PROGRESS
  COMPLAINT_RESOLVED
  COMPLAINT_REJECTED
  NOTICE_REG
  POLL_REG
  POLL_CLOSED
  POLL_RESULT
  SYSTEM
  TEST
}

enum PollStatus {
  PENDING
  IN_PROGRESS
  CLOSED
}

// ------------------------------
// USER / APART / RESI
// ------------------------------

model User {
  id       String   @id @default(uuid())
  username String   @unique
  password String
  contact  String   @unique
  name     String
  email    String   @unique
  role     UserRole @default(USER)
  isActive Boolean  @default(true)
  avatar   String

  createdAt  DateTime   @default(now())
  joinStatus JoinStatus @default(PENDING)

  apartment Apartment? @relation("ApartmentAdmin")

  residentId String?   @unique
  resident   Resident? @relation("UserResident", fields: [residentId], references: [id], onDelete: Cascade)

  notifications Notification[]
  complaints    Complaint[]    @relation("ComplaintUser")
  comments      Comment[]
  pollVotes     PollVote[]
  notices       Notice[]
  polls         Poll[]
}

model Apartment {
  id            String @id @default(uuid())
  apartmentName String @unique

  apartmentAddress          String
  description               String?
  apartmentManagementNumber String? // 관리사무소 번호

  startComplexNumber String // 아파트 단지 시작번호
  endComplexNumber   String // 아파트 단지 끝번호
  startDongNumber    String // 아파트 동 시작번호
  endDongNumber      String // 아파트 동 끝번호
  startFloorNumber   String // 아파트 최하층
  endFloorNumber     String // 아파트 최상층
  startHoNumber      String // 아파트 시작 호수
  endHoNumber        String // 아파트 끝 호수
  createdAt          DateTime @default(now())

  adminId String? @unique
  admin   User?   @relation("ApartmentAdmin", fields: [adminId], references: [id], onDelete: Cascade)

  residents  Resident[]
  notices    Notice[]
  complaints Complaint[]
  polls      Poll[]
  events     Event[]
  boards     Board[]
}

// User랑 별개로 존재
model Resident {
  id             String         @id @default(uuid())
  name           String
  contact        String
  building       String
  unitNumber     String
  isRegistered   Boolean        @default(false)
  approvalStatus ApprovalStatus @default(PENDING)
  residentStatus ResidentStatus @default(RESIDENCE)
  isHouseholder  IsHouseholder  @default(MEMBER)
  createdAt      DateTime       @default(now())

  user User? @relation("UserResident")

  apartmentId String
  apartment   Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
}

// ------------------------------
// BOARD / NOTICE / COMPLAINT / POLL
// ------------------------------

model Board {
  id          String    @id @default(uuid())
  type        BoardType
  apartmentId String
  apartment   Apartment @relation(fields: [apartmentId], references: [id])

  notices    Notice[]
  complaints Complaint[]
  polls      Poll[]
  Comment    Comment[]

  // 아파트별 게시판 1개 보장
  @@unique([apartmentId, type])
}

model Notice {
  id       String         @id @default(uuid())
  title    String
  content  String
  category NoticeCategory

  viewsCount Int     @default(0)
  isPinned   Boolean @default(false)

  // 공지 노출 기간
  startDate DateTime?
  endDate   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  boardId String
  board   Board  @relation(fields: [boardId], references: [id])

  comments Comment[]

  Apartment   Apartment? @relation(fields: [apartmentId], references: [id])
  apartmentId String?
  Event       Event?
}

model Complaint {
  id      String @id @default(uuid())
  title   String
  content String

  viewsCount Int     @default(0)
  isPublic   Boolean @default(true)

  status ComplaintStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation("ComplaintUser", fields: [userId], references: [id])

  boardId String
  board   Board  @relation(fields: [boardId], references: [id])

  comments Comment[]

  Apartment   Apartment? @relation(fields: [apartmentId], references: [id])
  apartmentId String?
}

model Poll {
  id        String     @id @default(uuid())
  title     String
  content   String
  startDate DateTime
  endDate   DateTime
  status    PollStatus @default(PENDING)

  buildingPermission Int      @default(0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  boardId String
  board   Board  @relation(fields: [boardId], references: [id])

  options PollOption[]
  votes   PollVote[]

  Apartment   Apartment? @relation(fields: [apartmentId], references: [id])
  apartmentId String?
  Event       Event?
}

// ------------------------------
// POLL+
// ------------------------------

model PollOption {
  id     String @id @default(uuid())
  title  String
  pollId String
  poll   Poll   @relation(fields: [pollId], references: [id], onDelete: Cascade)

  votes PollVote[]
}

model PollVote {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  pollId String
  poll   Poll   @relation(fields: [pollId], references: [id], onDelete: Cascade)

  optionId String?
  option   PollOption? @relation(fields: [optionId], references: [id])

  createdAt DateTime @default(now())

  @@unique([pollId, userId])
}

// ------------------------------
// COMMENT / NOTIFICATION / EVENT
// ------------------------------

model Comment {
  id        String   @id @default(uuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  boardType BoardType // 응답/요청 DTO
  boardId   String
  board     Board     @relation(fields: [boardId], references: [id])

  noticeId String?
  Notice   Notice? @relation(fields: [noticeId], references: [id], onDelete: Cascade)

  complaintId String?
  Complaint   Complaint? @relation(fields: [complaintId], references: [id], onDelete: Cascade)
}

model Notification {
  id               String           @id @default(uuid())
  content          String
  notificationType NotificationType
  notifiedAt       DateTime         @default(now())
  isChecked        Boolean          @default(false)

  complaintId String?
  noticeId    String?
  pollId      String?

  recipientId String @map("receiverId")
  recipient   User   @relation(fields: [recipientId], references: [id])
}

model Event {
  id        String        @id @default(uuid())
  title     String
  category  EventCategory
  boardType BoardType

  startDate DateTime
  endDate   DateTime

  createdAt DateTime @default(now())

  apartmentId String
  apartment   Apartment @relation(fields: [apartmentId], references: [id])

  // notice 또는 poll 중 하나만 존재하게 백엔드 로직에서 처리
  noticeId String? @unique
  notice   Notice? @relation(fields: [noticeId], references: [id])

  pollId String? @unique
  poll   Poll?   @relation(fields: [pollId], references: [id])
}
